 1. Example exam from [[https://ucilnica-fe.uni-lj.si/pluginfile.php/2894/mod_resource/content/4/AISWrittenExamExample.pdf | the subject repo]]
## Questions 1

### 1.  What is the definition of an autonomous agent?
-  An agent is a computer system that is capable of independent (autonomous) actions on behalf of its user or owner. They:
	- _are situated_ within an _environment_,
	- sense the environment, they are situaded in,
	- _act upon_ their environment over time __in pursuit of their own agenda__

### 2. What is the relation between artificial perception, cognition and recognition?
- _Perception_ is the process of recognising and interpreting sensory stimuli that enable an agent to _be aware of_ the presence of objects or other agents as well as their mutual relations and their surrounding environment.
- __Artificial__ _perception_ is an imitation of these $\uparrow$ processes that is implemented in artificial autonomous agents
- _Cognition_ is the process of translating the obtained _percepts_ of the already known objects, relations and events
- _Recognition_ is the perception of the already known objects, relations and events
1. So to conclude, __perception__ is the basis for __cognition__, since we need to perceive our surroundings to form _relevant concepts_ about it. While __recognition__ is the process of _applying already perceived relations_ onto a new set of events

### 3. What determines intelligent behaviour?
1. Intelligent behaviour is determined by:
	- The ability to _perceive one's environment_
	- The ability to _act in demanding and complex situations_
	- The ability to _learn and unerstand_ from _experience_
	- The ability to _use reasoning to solve problems_ and _discover hidden knowledge_
	- The ability to _apply knowledge in new situations_
	- The ability to _communicate with others_
	- The ability to _understand natural language_
	- _Creativity, curiosity, ingenuity..._
### 4. What is the difference between strong and weak AI?
1. __Strong AI__ is reserved for machines, which _fully achieve or exceed the human intellectual and cognitive skills_, whereas __weak AI__ are machines that can solve specific complex problems, but _do not employ the full range od human mental and cognitive abilities_ to do so
### 5. What are the basic principles of machine learning?
- Machine learning is the branch of artificial intelligence research that is based on _modeling environments from data_ and is related to the fields of __pattern recognition__ and __data mining__
1. The basic principles of machine learning are:
	- _Training data_
	- _A priori knowledge_
	- _Training algorithm_
	- _Knowledge model_

![[Pasted image 20250118171739.png]]

### 6. Describe the transition from Artificial Intelligence to Ambient Intelligence
- __Ambiental intelligence__ refers to electronic environments, that are _sensitive_ and _responsive_ to the presence of people
- In comparison to artificial intelligence, ambient intelligent systems nned to be _ubiquitous_, _unobtrusive_, _transparent_ and _intelligent_. It envisions users being surrounded by intelligent user interfaces, supported by networked ICT, embedded in everyday objects.
1.  It is uspposed to:
	- be _aware of the presence of people_,
	- _adapt_ to the users needs,
	- _intelligently respond_ to speech and gestures,
	- be capable of _engaging in intelligent discourse_,
	- be unobtrusive and _support relaxed interactions_,
	- include _interoperability between different environments_

## Questions 2:
### 1. Give your own example of a problem for which the solution is a description of the path from the initial to the final state in the problem state space.
- The __problem space__ is an abstract space, which includes _all the possible states of the problem_, that can be _generated by any combination of operators_  on _any combination of objects_.
	- It can contain one or more _final states_, that represent _a solution to the problem_. 
	- Finding the solution is _searching for the final state_ in a problem space.
1. My example of such a problem is path planning in robotics. The robot has a fixed origin pose and a goal pose, it needs to get from one to the other without hitting any obstales, while doing it as quickly and smoothly as possible. The path from the initial to the final state represents the joint configurations it needs, to get from the initial to the final point while satisfying the prespecified conditions.
### 2. What constitutes a solution to the problem that is decomposed to sub-problems?
- Knowing the structure of the problem, more complex problems can be _intelligently solved_ by _decomposing/dividin them_ into __sub-problems__, which are much easier to solve than the whole problem. 
1. _The solution_ of the entire proble is achieved by _combining the solutions of easier sub-problems_ into __a problem solving plan.__

### 3. Describe forward or backward facing chaining rules
- Forward and backward chainings of rules are both _knowledge base searching thechniques_, used for drawing inference from the knowledge base.
1. __Forward chaining of rules:__ (Also known as data-driven), can be described logicaly as a repeated aplication of [[Modeus ponens|modeus ponens]]. The algorithm _scans the inference rules_, untill it finds one, where the _condition is true_, therefore, it can _infer_, that the __outcome is also true__. The algorithm is __repeated until__ _the condition matches the desired outcome_, or until  _no more inference rules_ can be checked with respect to the _condition_ (data) in the working memory.
2. __Backward chaining of rules:__  (Also known as goal-driven), can be described as _searching backwards_ from the desired goals/outcomes. The algorithm _starts with the goal/outcome_ and scans through the knowledge database and chacks, _whether there are any any conditions/data_ that __support the outcome__

| **Forward Chaining**                                        | **Backward Chaining**                                       |
| ----------------------------------------------------------- | ----------------------------------------------------------- |
| Infer from the present to the future                        | Infer from the present to the past                          |
| Infer from ancestors/antecedents to descendants/consequents | Infer from descendants/consequents to ancestors/antecedents |
| Planning and controlling systems                            | System diagnostics                                          |
| Data-driven bottom-up search/reasoning                      | Goal-driven top-down search/reasoning                       |
| Search the conclusions that follow from the facts           | Search the facts that support the conclusions               |
| Explanation of the chain of reasoning is not possible       | Explanation of the chain of reasoning is possible           |


## Questions 3:

### 1. Give an example of knowledge representation in a selected knowledge representation scheme.
- To solve problems using computers, we need to represent the knowledge we have in a format, the computer can understand, so natural language is out of the question because of its complexity. We achieve that, _using various knowledge representation schemes_.
- _Different types of knowledge_ may require _different formal knowledge representation schemes_. 
- The most common knowledge representation schemes are:
	- Decision tables and decision trees
	- Production rules, rules with exceptions
	- The language of mathematical logic
	- Semantic networs and semantic frames
	- Fuzzy Petri nets
	- Regression trees
- Each knowledge representation scheme _may require a different method of inference_ from the inputed conditions
1. My example of a knowledge representation scheme is a __decision table__, they are _the simplest knowledge representation scheme_. Their drawback is the difficulty of matching the attributes and poor flexibility.

| Outlook  | Humidity | __Outdoor plans__ |
| -------- | -------- | ----------------- |
| Sunny    | High     | No                |
| Sunny    | Normal   | Yes               |
| Overcast | High     | Yes               |
| Overcast | Normal   | Yes               |
| Rainy    | High     | No                |
| Rainy    | Normal   | No                |

### 2. Prove the following proposition equivalence: $(A \lor B) \land (A\lor \neg B) \iff A$
- This propositional equivalence means: 
	- $(A \lor B) \land (A \lor \neg B)$ is _equivalent_ to $A$
	- Which means, the output of the _left proposition_ is solely dependent on the value of $A$
- This can be proven with a _truth table_

| __A__ | __B__ | $(A \lor B)$     | $(A \lor \neg B)$                  | $(A \lor B) \land (A \lor \neg B)$ |
| ----- | ----- | ---------------- | ---------------------------------- | ---------------------------------- |
| 0     | 0     | $(0 \lor 0) = 0$ | $(0 \lor \neg 0) = (0 \lor 1) = 1$ | $0 \land 1 = 0 = A$                |
| 0     | 1     | $(0 \lor 1) = 1$ | $(0 \lor \neg 1) = (0 \lor 0) = 0$ | $1 \land 0 = 0 = A$                |
| 1     | 0     | $(1 \lor 0) = 1$ | $(1 \lor \neg 0) = (1\lor 1) = 1$  | $1 \land 1 = 1 = A$                |
| 1     | 1     | $(1 \lor 1) = 1$ | $(1 \lor \neg 1) = (1\lor 0) = 1$  | $1 \land 1 = 1 = A$                |

From the table we can see, that _the propositions_ __are equivalent for every possible combination of A and B__, therefore _the statement is TRUE_

## Questions 4:

### 1. Convert the following prepositions to prolog causes:
```
"Something that eats the flesh of living beings is a carnivore."

"James likes all the movies that Nancy or Linda like."
```

- Ok, let's start with the _first example:_
	`Something that eats the flesh of living beings is a carnivore.`
	1. First, we need to identify the key _concepts_ and _relationships_:
		- The statement describes __a condition__ for being a carnivore
		- The condition is eating the flesh of living beings
	2. Second, we _break the statement down_ into a _conditional structure:_
		-  _if_ something eats the flesh of living beings, __then__ it is a carnivore
	3. Then we _translate the concept into prolog terms:_
		- The _entity_, or in this case `something`, is represented as a variable, such as `X`
		- The _relationship_ is represented as a predicate: `eats(X, flesh_of_living_beings)`, this statement checks, _whether X eats the flesh of living beings_ and returns a boolean responsive
		- The _conclusion_ is also represented as a predicate `carnivore(X)`
	4. Now we put it all together:
		- In prolog, _conditional statements_ are expressed with the `:-` operator
	The outcome is:
```prolog
carnivore(X) :- eats(X, flesh_of_living_beings).
```

- Now let's move on to the _second example:_
	`James likes all the movies that Nancy or Linda like.`
	1. First, we need to identify the key _concepts_ and _relationships_:
		- The statement describes __a condition__ for James liking movies
		- The condition is _the movie being liked,_ by Nancy __OR__ Linda
	2. Second, we _break the statement down_ into a _conditional structure:_
		-  _if_ Nancy __OR__ Linda like a movie, __then__ James also likes the movie.
	3. Then we _translate the concept into prolog terms:_
		- The _entity_, is fixed in this case, so we will represent it with a variable of the same name: `james`
		- The movie that James might like is also represented with a variable of the same name: `movie`
		- The _conditions_ for James liking the movie are also fixed, so they also get represented with variable sof the same names: `nancy` and `linda`
		- The _relationships_ are represented as predicates: `likes(linda, movie)`, `likes(nancy, movie)`. These statements checks, _whether Linda likes the movie_ and _whether Nancy likes the movie_ and return boolean responses
		- The statement states, that James likes the movie, if Linda __OR__ Nancy like it, we need to package these conditions in an __OR__ statement, in prolog this is represented using a semicolon `;`
		- The _conclusion_ is also represented as a predicate `likes(james, movie)`
	4. Now we put it all together:
		- In prolog, _conditional statements_ are expressed with the `:-` operator
	The outcome is:
```prolog
likes(james, Movie) :- (likes(linda, Movie) ; likes(nancy, Movie)).
```

### 2. Describe the way in which Prolog matches two terms
- The way prolog matches two terms is called __unification__, it means that Prolog checks, _whether the matched terms can be made to represent the same structure_. The unification algorithm follows the following rules:
	- Two _constants_ unify if they are __identical__
	- Two _structures_ unify if:
		- They have the same _predicate_ and _arity_ (number of arguments) __and__,
		- If all their _corresponding arguments_ also __match__
	- A _non instantiated variable_ can unify and then instantiate to any term in both directions
	- Two _non instantiated variables_ unify and __become an identical variable__
- The unification is _triggered_ by the `=` operator, with the two terms __at either side__

### 3. What are the results of the unification of the following terms:
```prolog
?- triangle(X,t(Y1,1),t(3,3)) = triangle(t(1,1),t(4,Y2),t(3,Z2).

?- X = 3 + 5, Y is 3*X.
```
- _First example:_
	1. Comparing the _functor_ (triangle):
		- Both terms have _the same functor_, in this case, it's `triangle`
		- Both terms have the same _arity_ of 3 (the number of arguments in the functor)
	2. Comparing the _arguments_
		- For a unification to be true, all arguments in the terms _must match_, as described [[#2. Describe the way in which Prolog matches two terms |here]] 	
		
|                 |    ARG1    |     ARG2     |   ARG3    |
| :-------------: | :--------: | :----------: | :-------: |
|    _Term 1_     |    `X`     |  `t(Y1,1)`   | `t(3,3)`  |
|    _Term 2_     |  `t(1,1)`  |  `t(4,Y2)`   | `t(3,Z2)` |
| __Unification__ | `X=t(1,1)` | `Y1=4, Y2=1` |  `Z2=3`   |
- So the __final outcome of the unification is:__
```prolog
X=t(1,1), Y1=4, Y2=1, Z2=3.
```

- _Second example:_
	1. Evaluate the _first assignment:_ `X=3+5`
		- In prolog, `3+5` is treated _as a term_, which is not evaluated imediately, unless we use the `is` operator, thus `X=3+5` _is instatniated as a unity_
	2. Evaluate the _second assignment:_ `Y is 3*X`
		- The `is` operator _instantiates `X` _as a number_. Since `X = 3+5` , it gets _added_ and the outcpme is:
```prolog
X = 3+5,
Y = 24.
```


## Questions 5:

### 1. Explain why abductive and inductive reasoning are inherently uncertain
- __Abductive reasoning:__ Infers the most likely explanation for a set of observations.
    `If A→B, and B is observed, then A is likely.`
	- _Why It’s Uncertain:_
	    - _Incomplete Explanations_: Other plausible causes may exist. `Wet grass → Rain, but could also be a sprinkler.`
	    - _Non-Guaranteed Outcomes_ Premises true ≠ Conclusion true. `Fever → Flu, but could indicate other illnesses.`
	    - _Subjectivity_: The "best explanation" depends on context and biases.

- __Inductive Reasoning:__ Draws general conclusions from specific observations.
    `Observation 1, 2, ..., n → General Conclusion.`
	- _Why It’s Uncertain_:
	    - _Patterns, Not Proof_: Patterns in the past may not persist. `Sun rises daily → Will rise tomorrow (highly likely but not certain).`
	    - _Limited Data_: Observations may not represent the whole. `Observing only white swans → Not all swans are white.`
	    - _Revisability_: New evidence can revise conclusions. `Market trends may shift unpredictably.`

---

- **Abduction**: Plausible but not definitive explanations.
- **Induction**: Generalizes but relies on incomplete patterns.
- **Both**: Useful in uncertainty but need validation.

1.  Both methods are valuable for reasoning in situations of incomplete knowledge but always involve a degree of risk and require validation or further evidence to reduce uncertainty.


### 2. Give a simple example of a Bayesian network:
- Bayesian reasoning is an application of _probability theory_ to _inductive and abductive reasoning_.
- It uses _probability theory_ and information about _independence_ as well as reasoning from evidence to general conclusions ([[#1. Explain why abductive and inductive reasoning are inherently uncertainin |inductive reasoning]]) or from causes to effects ([[#1. Explain why abductive and inductive reasoning are inherently uncertain |abductive reasoning]])
- _Bayesian networks_ are a practical way of managing _probabilistic inference_ when multiple variables are involved. They __make assumptions about the relevance of some conditions to others__. Once the assumptions are made, the _joint probabilistic distribution_ can be factored, so that __there are fewer parameters that must be specified__.

1. My example of a simple Bayesian network:
	![[Pasted image 20250119164545.png]]
	- The circles, containing the letters, $A, B, and \space C$ _represent  the variables of the network_
	- The connections, or lack of them, _represent the dependence of the variables:_
		- __No connections__ (edges): The variables have _no dependence_, they are completely independent of each other (in this example A and B)
		- __Directed connection__ (edge): The variables have _conditional independence_
	$$P(A,B,C) = P(C|A,B)\cdot P(A) \cdot P(B)$$
### 3. Describe the main operators of genetic algorithms
- Genetic algorithms are an AI training strategy that _mimics the process of natural selection_, or the survival of the fittest. The basic principles are:
	- _selection_
	- _reproduction_
	- _inheritance_
	- _crossover_
	- _mutation_
- The average _genetic algorithm_ consist of 6 main steps:
	1. __Start:__ This step generates a random initial population of $n$ chromosomes, this is the starting point from which the algorithm will attempt to _optimise their traits_
	2. __Fitness:__ This step evaluates the fitness of each member of the population, the _fitness_ is usually the value of the _objective function_ in the optimisation problem we're trying to solve
	3. __New population:__ Creates a new "generation" of the population by repeating the following steps untill the _new population is complete_:
		1. __Selection:__ selects 2 _"parent" chromosomes_ from the population, _based on thir fitness_, the higher the fitness score, the better the chance of getting selected
		2. __Crossover:__ applies a crossover of the _parent traits_ to the offspring, without this, _the child would be the exact copy of their parent_
		3. __Mutation:__ With a mutation probability, we _mutate the new offspring_ at each position in the chromosome (each trait) to introduce a perturbation and encourage the betterment of the species
		4. __Selection:__ _Place the_ newly augmented offspring _into the population_
	4. __Replace:__ Use the newly generated population _for a further iteration of the algorithm_
	5. __Test:__ If the _end condition is satisfied_, stop and _return the best solution_ in the current generation
	6. __Loop:__ If the _condition_ in the previous step is _not met, we repeat the cycle from step 2._
